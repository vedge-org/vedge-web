/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * Vedge API
 * ÏïîÌëú Î∞©ÏßÄ Ìã∞Ïºì ÏòàÎß§ ÏÑúÎπÑÏä§ Vedge API Î¨∏ÏÑú
 * OpenAPI spec version: 1.0
 */
import {
  createInfiniteQuery,
  createMutation,
  createQuery
} from '@tanstack/svelte-query'
import type {
  CreateInfiniteQueryOptions,
  CreateInfiniteQueryResult,
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey
} from '@tanstack/svelte-query'
import type {
  ReserveTicketDto,
  TicketsControllerGetMyTicketsParams
} from '../../schemas'
import { customInstance } from '../../mutator/axios';
import type { ErrorType, BodyType } from '../../mutator/axios';


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary Ìã∞Ïºì ÏòàÎß§
 */
export const ticketsControllerReserveTickets = (
    reserveTicketDto: BodyType<ReserveTicketDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/tickets/reserve`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reserveTicketDto
    },
      options);
    }
  


export const getTicketsControllerReserveTicketsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerReserveTickets>>, TError,{data: BodyType<ReserveTicketDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerReserveTickets>>, TError,{data: BodyType<ReserveTicketDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ticketsControllerReserveTickets>>, {data: BodyType<ReserveTicketDto>}> = (props) => {
          const {data} = props ?? {};

          return  ticketsControllerReserveTickets(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TicketsControllerReserveTicketsMutationResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerReserveTickets>>>
    export type TicketsControllerReserveTicketsMutationBody = BodyType<ReserveTicketDto>
    export type TicketsControllerReserveTicketsMutationError = ErrorType<void>

    /**
 * @summary Ìã∞Ïºì ÏòàÎß§
 */
export const createTicketsControllerReserveTickets = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerReserveTickets>>, TError,{data: BodyType<ReserveTicketDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): CreateMutationResult<
        Awaited<ReturnType<typeof ticketsControllerReserveTickets>>,
        TError,
        {data: BodyType<ReserveTicketDto>},
        TContext
      > => {

      const mutationOptions = getTicketsControllerReserveTicketsMutationOptions(options);

      return createMutation(mutationOptions);
    }
    /**
 * @summary ÎÇ¥ Ìã∞Ïºì Î™©Î°ù Ï°∞Ìöå
 */
export const ticketsControllerGetMyTickets = (
    params?: TicketsControllerGetMyTicketsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/tickets/my-tickets`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTicketsControllerGetMyTicketsQueryKey = (params?: TicketsControllerGetMyTicketsParams,) => {
    return [`/tickets/my-tickets`, ...(params ? [params]: [])] as const;
    }

    
export const getTicketsControllerGetMyTicketsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError = ErrorType<void>>(params?: TicketsControllerGetMyTicketsParams, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetMyTicketsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>> = ({ signal }) => ticketsControllerGetMyTickets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetMyTicketsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>>
export type TicketsControllerGetMyTicketsInfiniteQueryError = ErrorType<void>


/**
 * @summary ÎÇ¥ Ìã∞Ïºì Î™©Î°ù Ï°∞Ìöå
 */

export function createTicketsControllerGetMyTicketsInfinite<TData = Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError = ErrorType<void>>(
 params?: TicketsControllerGetMyTicketsParams, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetMyTicketsInfiniteQueryOptions(params,options)

  const query = createInfiniteQuery(queryOptions) as CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTicketsControllerGetMyTicketsQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError = ErrorType<void>>(params?: TicketsControllerGetMyTicketsParams, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetMyTicketsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>> = ({ signal }) => ticketsControllerGetMyTickets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetMyTicketsQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>>
export type TicketsControllerGetMyTicketsQueryError = ErrorType<void>


/**
 * @summary ÎÇ¥ Ìã∞Ïºì Î™©Î°ù Ï°∞Ìöå
 */

export function createTicketsControllerGetMyTickets<TData = Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError = ErrorType<void>>(
 params?: TicketsControllerGetMyTicketsParams, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetMyTickets>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetMyTicketsQueryOptions(params,options)

  const query = createQuery(queryOptions) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Ìã∞Ïºì ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const ticketsControllerGetTicketDetail = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/tickets/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getTicketsControllerGetTicketDetailQueryKey = (id: string,) => {
    return [`/tickets/${id}`] as const;
    }

    
export const getTicketsControllerGetTicketDetailInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError = ErrorType<void>>(id: string, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetTicketDetailQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>> = ({ signal }) => ticketsControllerGetTicketDetail(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetTicketDetailInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>>
export type TicketsControllerGetTicketDetailInfiniteQueryError = ErrorType<void>


/**
 * @summary Ìã∞Ïºì ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function createTicketsControllerGetTicketDetailInfinite<TData = Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError = ErrorType<void>>(
 id: string, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetTicketDetailInfiniteQueryOptions(id,options)

  const query = createInfiniteQuery(queryOptions) as CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTicketsControllerGetTicketDetailQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError = ErrorType<void>>(id: string, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetTicketDetailQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>> = ({ signal }) => ticketsControllerGetTicketDetail(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetTicketDetailQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>>
export type TicketsControllerGetTicketDetailQueryError = ErrorType<void>


/**
 * @summary Ìã∞Ïºì ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function createTicketsControllerGetTicketDetail<TData = Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError = ErrorType<void>>(
 id: string, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetTicketDetail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetTicketDetailQueryOptions(id,options)

  const query = createQuery(queryOptions) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Ìã∞Ïºì Ï∑®ÏÜå
 */
export const ticketsControllerCancelTicket = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/tickets/cancel/${id}`, method: 'POST'
    },
      options);
    }
  


export const getTicketsControllerCancelTicketMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerCancelTicket>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerCancelTicket>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ticketsControllerCancelTicket>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  ticketsControllerCancelTicket(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TicketsControllerCancelTicketMutationResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerCancelTicket>>>
    
    export type TicketsControllerCancelTicketMutationError = ErrorType<void>

    /**
 * @summary Ìã∞Ïºì Ï∑®ÏÜå
 */
export const createTicketsControllerCancelTicket = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:CreateMutationOptions<Awaited<ReturnType<typeof ticketsControllerCancelTicket>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): CreateMutationResult<
        Awaited<ReturnType<typeof ticketsControllerCancelTicket>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTicketsControllerCancelTicketMutationOptions(options);

      return createMutation(mutationOptions);
    }
    /**
 * @summary ÏòàÎß§ Í∞ÄÎä•Ìïú Ï¢åÏÑù Ï°∞Ìöå
 */
export const ticketsControllerGetAvailableSeats = (
    scheduleId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/tickets/available/${scheduleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getTicketsControllerGetAvailableSeatsQueryKey = (scheduleId: string,) => {
    return [`/tickets/available/${scheduleId}`] as const;
    }

    
export const getTicketsControllerGetAvailableSeatsInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError = ErrorType<unknown>>(scheduleId: string, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetAvailableSeatsQueryKey(scheduleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>> = ({ signal }) => ticketsControllerGetAvailableSeats(scheduleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scheduleId), ...queryOptions} as CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetAvailableSeatsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>>
export type TicketsControllerGetAvailableSeatsInfiniteQueryError = ErrorType<unknown>


/**
 * @summary ÏòàÎß§ Í∞ÄÎä•Ìïú Ï¢åÏÑù Ï°∞Ìöå
 */

export function createTicketsControllerGetAvailableSeatsInfinite<TData = Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError = ErrorType<unknown>>(
 scheduleId: string, options?: { query?:CreateInfiniteQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetAvailableSeatsInfiniteQueryOptions(scheduleId,options)

  const query = createInfiniteQuery(queryOptions) as CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTicketsControllerGetAvailableSeatsQueryOptions = <TData = Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError = ErrorType<unknown>>(scheduleId: string, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTicketsControllerGetAvailableSeatsQueryKey(scheduleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>> = ({ signal }) => ticketsControllerGetAvailableSeats(scheduleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scheduleId), ...queryOptions} as CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData> & { queryKey: QueryKey }
}

export type TicketsControllerGetAvailableSeatsQueryResult = NonNullable<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>>
export type TicketsControllerGetAvailableSeatsQueryError = ErrorType<unknown>


/**
 * @summary ÏòàÎß§ Í∞ÄÎä•Ìïú Ï¢åÏÑù Ï°∞Ìöå
 */

export function createTicketsControllerGetAvailableSeats<TData = Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError = ErrorType<unknown>>(
 scheduleId: string, options?: { query?:CreateQueryOptions<Awaited<ReturnType<typeof ticketsControllerGetAvailableSeats>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getTicketsControllerGetAvailableSeatsQueryOptions(scheduleId,options)

  const query = createQuery(queryOptions) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



