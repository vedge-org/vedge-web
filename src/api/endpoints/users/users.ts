/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * Vedge API
 * ÏïîÌëú Î∞©ÏßÄ Ìã∞Ïºì ÏòàÎß§ ÏÑúÎπÑÏä§ Vedge API Î¨∏ÏÑú
 * OpenAPI spec version: 1.0
 */
import { createInfiniteQuery, createMutation, createQuery } from '@tanstack/svelte-query';
import type {
	CreateInfiniteQueryOptions,
	CreateInfiniteQueryResult,
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey
} from '@tanstack/svelte-query';
import type { UpdateUserDto } from '../../schemas';
import { customInstance } from '../../mutator/axios';
import type { ErrorType, BodyType } from '../../mutator/axios';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const usersControllerGetMe = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<unknown>({ url: `/users/me`, method: 'GET', signal }, options);
};

export const getUsersControllerGetMeQueryKey = () => {
	return [`/users/me`] as const;
};

export const getUsersControllerGetMeInfiniteQueryOptions = <
	TData = Awaited<ReturnType<typeof usersControllerGetMe>>,
	TError = ErrorType<void>
>(options?: {
	query?: CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetMe>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersControllerGetMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetMe>>> = ({ signal }) =>
		usersControllerGetMe(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetMe>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UsersControllerGetMeInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof usersControllerGetMe>>
>;
export type UsersControllerGetMeInfiniteQueryError = ErrorType<void>;

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function createUsersControllerGetMeInfinite<
	TData = Awaited<ReturnType<typeof usersControllerGetMe>>,
	TError = ErrorType<void>
>(options?: {
	query?: CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetMe>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUsersControllerGetMeInfiniteQueryOptions(options);

	const query = createInfiniteQuery(queryOptions) as CreateInfiniteQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getUsersControllerGetMeQueryOptions = <
	TData = Awaited<ReturnType<typeof usersControllerGetMe>>,
	TError = ErrorType<void>
>(options?: {
	query?: CreateQueryOptions<Awaited<ReturnType<typeof usersControllerGetMe>>, TError, TData>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersControllerGetMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetMe>>> = ({ signal }) =>
		usersControllerGetMe(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetMe>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UsersControllerGetMeQueryResult = NonNullable<
	Awaited<ReturnType<typeof usersControllerGetMe>>
>;
export type UsersControllerGetMeQueryError = ErrorType<void>;

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function createUsersControllerGetMe<
	TData = Awaited<ReturnType<typeof usersControllerGetMe>>,
	TError = ErrorType<void>
>(options?: {
	query?: CreateQueryOptions<Awaited<ReturnType<typeof usersControllerGetMe>>, TError, TData>;
	request?: SecondParameter<typeof customInstance>;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUsersControllerGetMeQueryOptions(options);

	const query = createQuery(queryOptions) as CreateQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const usersControllerUpdateMe = (
	updateUserDto: BodyType<UpdateUserDto>,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<unknown>(
		{
			url: `/users/me`,
			method: 'PUT',
			headers: { 'Content-Type': 'application/json' },
			data: updateUserDto
		},
		options
	);
};

export const getUsersControllerUpdateMeMutationOptions = <
	TError = ErrorType<void>,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersControllerUpdateMe>>,
		TError,
		{ data: BodyType<UpdateUserDto> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersControllerUpdateMe>>,
	TError,
	{ data: BodyType<UpdateUserDto> },
	TContext
> => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersControllerUpdateMe>>,
		{ data: BodyType<UpdateUserDto> }
	> = (props) => {
		const { data } = props ?? {};

		return usersControllerUpdateMe(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersControllerUpdateMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersControllerUpdateMe>>
>;
export type UsersControllerUpdateMeMutationBody = BodyType<UpdateUserDto>;
export type UsersControllerUpdateMeMutationError = ErrorType<void>;

/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï
 */
export const createUsersControllerUpdateMe = <
	TError = ErrorType<void>,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersControllerUpdateMe>>,
		TError,
		{ data: BodyType<UpdateUserDto> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateMutationResult<
	Awaited<ReturnType<typeof usersControllerUpdateMe>>,
	TError,
	{ data: BodyType<UpdateUserDto> },
	TContext
> => {
	const mutationOptions = getUsersControllerUpdateMeMutationOptions(options);

	return createMutation(mutationOptions);
};
/**
 * @summary ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const usersControllerGetSession = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<void>({ url: `/users/me/session`, method: 'GET', signal }, options);
};

export const getUsersControllerGetSessionQueryKey = () => {
	return [`/users/me/session`] as const;
};

export const getUsersControllerGetSessionInfiniteQueryOptions = <
	TData = Awaited<ReturnType<typeof usersControllerGetSession>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetSession>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersControllerGetSessionQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetSession>>> = ({
		signal
	}) => usersControllerGetSession(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetSession>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UsersControllerGetSessionInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof usersControllerGetSession>>
>;
export type UsersControllerGetSessionInfiniteQueryError = ErrorType<unknown>;

/**
 * @summary ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function createUsersControllerGetSessionInfinite<
	TData = Awaited<ReturnType<typeof usersControllerGetSession>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: CreateInfiniteQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetSession>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customInstance>;
}): CreateInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUsersControllerGetSessionInfiniteQueryOptions(options);

	const query = createInfiniteQuery(queryOptions) as CreateInfiniteQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getUsersControllerGetSessionQueryOptions = <
	TData = Awaited<ReturnType<typeof usersControllerGetSession>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: CreateQueryOptions<Awaited<ReturnType<typeof usersControllerGetSession>>, TError, TData>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersControllerGetSessionQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerGetSession>>> = ({
		signal
	}) => usersControllerGetSession(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof usersControllerGetSession>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UsersControllerGetSessionQueryResult = NonNullable<
	Awaited<ReturnType<typeof usersControllerGetSession>>
>;
export type UsersControllerGetSessionQueryError = ErrorType<unknown>;

/**
 * @summary ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function createUsersControllerGetSession<
	TData = Awaited<ReturnType<typeof usersControllerGetSession>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: CreateQueryOptions<Awaited<ReturnType<typeof usersControllerGetSession>>, TError, TData>;
	request?: SecondParameter<typeof customInstance>;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUsersControllerGetSessionQueryOptions(options);

	const query = createQuery(queryOptions) as CreateQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}
